name: cd-backend-pipeline

on:
  push:
    branches: [ main ]
    paths:
      - 'back/**' # Mantém o gatilho apenas para mudanças no backend

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Essencial para o OIDC funcionar
      contents: read

    steps:
      - name: Checkout do código
        uses: actions/checkout@v4

      - name: Configurar Credenciais AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Setup JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'corretto'
          java-version: '17'

      - name: Build do JAR
        run: |
          cd back/cadastros-usuario
          chmod +x ./mvnw
          ./mvnw clean package -DskipTests

      - name: Upload JAR para S3
        run: |
          # Mantém o envio para o seu bucket de templates
          aws s3 cp back/cadastros-usuario/target/*.jar s3://${{ vars.BUCKET_TEMPLATES }}/app.jar

      - name: Deploy via SSM (Atualização de Instâncias)
        run: |
          # O comando permanece via SSM, mas agora aponta para o log correto 
          # e garante a execução do run.sh profissional.
          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=tag:aws:autoscaling:groupName,Values=${{ vars.PROJETO_NOME }}-asg" \
            --parameters 'commands=[
              "aws s3 cp s3://${{ vars.BUCKET_TEMPLATES }}/app.jar /home/ec2-user/app.jar",
              "chown ec2-user:ec2-user /home/ec2-user/app.jar",
              "fuser -k 8080/tcp || true",
              "sudo -u ec2-user nohup /home/ec2-user/run.sh > /home/ec2-user/app-exec.log 2>&1 &"
            ]'